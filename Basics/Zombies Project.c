#pragma config(Sensor, S4,     sonar,          sensorSONAR)

// *!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

// Starts the program

task main()

{

	// Defines the needed variables for the code

	int x = 1;

	int y;

	int counter = 0;

	// Defines two arrays that are both made up of floats

	float a[5];

	float b[5];

	// Defines the side length of each individual square in the grid

	int squarelength = 22;

	// Uses motor encoders to define a target that the robot will need to reach in order to travel exactly 1 square

	float target = 360/(5.5 * PI) * squarelength;

	// Creates a loop that runs 5 times

	while(x<=5)

	{

		// Resets motor encoders

		nMotorEncoder[motorB] = 0;

		nMotorEncoder[motorC] = 0;

		// Allows the robot to move forward exactly one square

		while(nMotorEncoder[motorB] < target)

		{

			motor[motorB] = 25;

			motor[motorC] = 25;

		}

		// Stops motors

		motor[motorB] = 0;

		motor[motorC] = 0;

		// Uses the sensor value to draw an ellipse that represnts each object

		y = SensorValue[sonar];

		drawEllipse(x * 15 + 12.5 - 5, y/squarelength * 15 + 2 + 5, x * 15 + 12.5 + 5, y/squarelength * 15 + 2 - 5);

		delay(1000);

		// Uses an if/else statement to define the cooridnates of a zombie that is one block away

		if (y>(squarelength - 11)&&y<(squarelength + 11))

		{

			b[counter] = squarelength;

			a[counter] = x * squarelength;

			playSound(soundFastUpwardTones);

			counter++;

		}

		// Uses an if/else statement to define the cooridnates of a zombie that is two blocks away

		else if (y>(2 * squarelength - 11) && y<(squarelength * 2 + 11))

		{

			b[counter] = squarelength * 2;

			a[counter] = x * squarelength;

			playSound(soundFastUpwardTones);

			counter++;

		}

		// Uses an if/else statement to define the cooridnates of a zombie that is three blocks away

		else if (y>(3 * squarelength - 11) && y<(squarelength * 3 + 11))

		{

			b[counter] = squarelength * 3;

			a[counter] = x * squarelength;

			playSound(soundFastUpwardTones);

			counter++;

		}

		// Uses an if/else statement to define the cooridnates of a zombie that is four blocks away

		else if (y>(4 * squarelength - 11) && y<(squarelength * 4 + 11))

		{

			b[counter] = squarelength * 4;

			a[counter] = x * squarelength;

			playSound(soundFastUpwardTones);

			counter++;

		}

		// Uses an if/else statement to tell the robot what to do if it doesn't see a "zombie"

		else

		{

			delay(1000);

		}

		x++;

	}

	// Types out the coordinates for each point (in centimeters starting from the bottom left corner)

	eraseDisplay();

	displayTextLine(2, "%f %f", a[0], b[0]);

	displayTextLine(3, "%f %f", a[1], b[1]);

	displayTextLine(4, "%f %f", a[2], b[2]);

	displayTextLine(5, "%f %f", a[3], b[3]);

	displayTextLine(6, "%f %f", a[4], b[4]);

	// Scales down the real life grid and displays it on the screen

	delay(1000);

	eraseDisplay();

	drawRect(12.5, 17, 27.5, 2);

	drawRect(12.5, 32, 27.5, 17);

	drawRect(12.5, 47, 27.5, 32);

	drawRect(12.5, 62, 27.5, 47);

	drawRect(27.5, 17, 42.5, 2);

	drawRect(27.5, 32, 42.5, 17);

	drawRect(27.5, 47, 42.5, 32);

	drawRect(27.5, 62, 42.5, 47);

	drawRect(42.5, 17, 57.5, 2);

	drawRect(42.5, 32, 57.5, 17);

	drawRect(42.5, 47, 57.5, 32);

	drawRect(42.5, 62, 57.5, 47);

	drawRect(57.5, 17, 72.5, 2);

	drawRect(57.5, 32, 72.5, 17);

	drawRect(57.5, 47, 72.5, 32);

	drawRect(57.5, 62, 72.5, 47);

	drawRect(72.5, 17, 87.5, 2);

	drawRect(72.5, 32, 87.5, 17);

	drawRect(72.5, 47, 87.5, 32);

	drawRect(72.5, 62, 87.5, 47);

	// Graphs each "zombie", showing where it is in relation to the rectangle (accounting for any initial mistakes by the sonar sensor)

	fillEllipse(a[0]/squarelength * 15 + 12.5 - 2, b[0]/squarelength * 15 + 2 + 2, a[0]/squarelength * 15 + 12.5 + 2, b[0]/squarelength * 15 + 2 - 2);

	fillEllipse(a[1]/squarelength * 15 + 12.5 - 2, b[1]/squarelength * 15 + 2 + 2, a[1]/squarelength * 15 + 12.5 + 2, b[1]/squarelength * 15 + 2 - 2);

	fillEllipse(a[2]/squarelength * 15 + 12.5 - 2, b[2]/squarelength * 15 + 2 + 2, a[2]/squarelength * 15 + 12.5 + 2, b[2]/squarelength * 15 + 2 - 2);

	fillEllipse(a[3]/squarelength * 15 + 12.5 - 2, b[3]/squarelength * 15 + 2 + 2, a[3]/squarelength * 15 + 12.5 + 2, b[3]/squarelength * 15 + 2 - 2);

	fillEllipse(a[4]/squarelength * 15 + 12.5 - 2, b[4]/squarelength * 15 + 2 + 2, a[4]/squarelength * 15 + 12.5 + 2, b[4]/squarelength * 15 + 2 - 2);

	delay(1000);

	// Resets all the motors and motor encoders

	nMotorEncoder[motorB] = 0;

	nMotorEncoder[motorC] = 0;

	// Moves the robot back to the starting position

	while(nMotorEncoder[motorB] > (-6 * target))

	{

		motor[motorB] = -25;

		motor[motorC] = -25;

	}

	// Turns the robot so that it faces the grid

	nMotorEncoder[motorB] = 0;

	nMotorEncoder[motorC] = 0;

	while(nMotorEncoder[motorC] < (90 * 2 * 16.7/5.5))

	{

		motor[motorB] = 0;

		motor[motorC] = 25;

	}

	// Sets a loop that runs 5 times (once for each "zombie" that needs to be "killed"

	int count = 0;

	while (count <=4)

	{

		// Resets the motors and the motor encoders

		nMotorEncoder[motorB] = 0;

		nMotorEncoder[motorC] = 0;

		motor[motorB] = 0;

		motor[motorC] = 0;

		delay(5000);

		// Uses the arctan to calculate how much the robot has to turn in order to face the object

		while(nMotorEncoder[motorB] < (90 - atan(b[count]/a[count]) * 180/PI) * 2 * 16.7/5.5 + 15)

		{

			motor[motorB] = 25;

			motor[motorC] = 0;

		}

		nMotorEncoder[motorB] = 0;

		nMotorEncoder[motorC] = 0;

		// Uses the Pythagorean theorem to move the robot the distance that it needs to go in order to "kill" the "zombie"

		while(nMotorEncoder[motorB] < (sqrt(a[count] * a[count] + b[count] * b[count]) + 4) * 360/(5.5 * PI))

		{

			motor[motorB] = 25;

			motor[motorC] = 25;

			motor[motorA] = 50;

		}

		nMotorEncoder[motorB] = 0;

		nMotorEncoder[motorC] = 0;

		motor[motorA] = 0;

		// Plays a sound when it hits the zombie

		playSound(soundFastUpwardTones);

		// Uses the Pythagorean theorem to move the robot back to its starting position

		while(nMotorEncoder[motorB] > - 1 * (sqrt(a[count] * a[count] + b[count] * b[count]) + 3) * 360/(5.5 * PI))

		{

			motor[motorB] = -25;

			motor[motorC] = -25;

		}

		nMotorEncoder[motorB] = 0;

		nMotorEncoder[motorC] = 0;

		// Uses the arctan to orient the robot so that it faces the correct direction

		while(nMotorEncoder[motorB] > (-90 + atan(b[count]/a[count]) * 180/PI) * 2 * 18.5/5.5 - 15)

		{

			motor[motorB] = -25;

			motor[motorC] = 0;

		}

		count++;

		motor[motorB] = 0;

		motor[motorC] = 0;

	}

	// Plays a song for celebration

	nVolume = 4;

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(600);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(246.94, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(185, 1000);

	delay(300);

	clearSounds();

	delay(600);

	playTone(277.18, 1000);

	delay(1200);

	clearSounds();

	playTone(277.18, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(246.94, 1000);

	delay(600);

	clearSounds();

	playTone(233.08, 1000);

	delay(600);

	clearSounds();

	playTone(233.08, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(600);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(246.94, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(277.18, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(207.65, 1000);

	delay(300);

	clearSounds();

	playTone(185, 1000);

	delay(300);

	clearSounds();

	delay(600);

	playTone(277.18, 1000);

	delay(1200);

	clearSounds();

	playTone(277.18, 1000);

	delay(300);

	clearSounds();

	playTone(311.13, 1000);

	delay(300);

	clearSounds();

	playTone(246.94, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(600);

	clearSounds();

	playTone(207.65, 1000);

	delay(600);

	clearSounds();

	// Ends the program

	delay(1000);

}
