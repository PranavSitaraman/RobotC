#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          mediumMotor,   tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp = 5.75;

	float Ki = 0.01;

	float Kd = 0.1;

	float taruplimit = 15;

	float motortarget = 30.0;

	float integraluplimit = 50.0;

	float leftvalue = 60.0;

	float rightvalue = 63.0;

	float tardownlimit = 0.0 - taruplimit;

	float integraldownlimit = 0.0 - integraluplimit;

	float integral = 0.0;

	float integraltarget = 0.0;

	float derivative = 0.0;

	float lastError = 0.0;

	float error;

	float turn;

	float powerB;

	float powerC;

	long x;

	float xvalue;

	long y;

	long z;

	long a;

	float avalue;

	long b;

	long c;

	float tar = leftvalue-rightvalue;

	float derivativesetpoint = 0.0;

	float straighttarget = 360/(1.2 * PI) * 0.79;

	float slightturntarget = 20 * 7.5/1.2;

	float largeturntarget = 70 * 7.5/1.2;

	while (true)

	{

		getColorRGB(S2, x, y, z);

		getColorRGB(S3, a, b, c);

		xvalue = (float)(x);

		avalue = (float)(a);

		if (tardownlimit<xvalue-avalue & xvalue-avalue<taruplimit)

		{

			tar = xvalue - avalue;

		}

		else

		{

			tar = leftvalue-rightvalue;

		}

		error = xvalue - avalue - tar;

		integral = integral+error;

		if (error < derivativesetpoint)

		{

			derivative = derivativesetpoint - (fabs(error - lastError))/2;

		}

		else

		{

			derivative = (fabs(error - lastError))/2;

		}

		turn = (Kp*error)+(Ki*integral)+(Kd*derivative);

		if (xvalue<20 & avalue>20)

		{
			motor[motorB] = 0;

			motor[motorC] = 0;

			nMotorEncoder[motorB] = 0;

			nMotorEncoder[motorC] = 0;

			while(nMotorEncoder[motorC] < slightturntarget)

			{

				motor[motorB] = -5;

				motor[motorC] = 30;

			}

			if (avalue<20)

			{

				motor[motorB] = 0;

				motor[motorC] = 0;

				nMotorEncoder[motorB] = 0;

				nMotorEncoder[motorC] = 0;

				while(nMotorEncoder[motorB] < slightturntarget)

				{

					motor[motorB] = 30;

					motor[motorC] = -5;

				}

				motor[motorB] = 0;

				motor[motorC] = 0;

				nMotorEncoder[motorB] = 0;

				nMotorEncoder[motorC] = 0;

				while(nMotorEncoder[motorB] < straighttarget)

				{

					motor[motorB] = 30;

					motor[motorC] = 30;

				}

			}

			else

			{
				motor[motorB] = 0;

				motor[motorC] = 0;

				nMotorEncoder[motorB] = 0;

				nMotorEncoder[motorC] = 0;

				while(nMotorEncoder[motorC] < largeturntarget)

				{

					motor[motorB] = -5;

					motor[motorC] = 30;

				}

			}

		}

		else

		{

			if (xvalue>20 & avalue<20)

			{

				motor[motorB] = 0;

				motor[motorC] = 0;

				nMotorEncoder[motorB] = 0;

				nMotorEncoder[motorC] = 0;

				while(nMotorEncoder[motorB] < slightturntarget)

				{

					motor[motorB] = 30;

					motor[motorC] = -5;

				}

				if (avalue<20)

				{

					motor[motorB] = 0;

					motor[motorC] = 0;

					nMotorEncoder[motorB] = 0;

					nMotorEncoder[motorC] = 0;

					while(nMotorEncoder[motorC] < slightturntarget)

					{

						motor[motorB] = -5;

						motor[motorC] = 30;

					}

					motor[motorB] = 0;

					motor[motorC] = 0;

					nMotorEncoder[motorB] = 0;

					nMotorEncoder[motorC] = 0;


					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = 30;

						motor[motorC] = 30;

					}

				}

				else

				{

					motor[motorB] = 0;

					motor[motorC] = 0;

					nMotorEncoder[motorB] = 0;

					nMotorEncoder[motorC] = 0;

					while(nMotorEncoder[motorB] < largeturntarget)

					{

						motor[motorB] = 30;

						motor[motorC] = -5;

					}

				}

			}

			else

			{

				powerB = motortarget+turn;

				powerC = motortarget-turn;

				motor[motorB] = powerB;

				motor[motorC] = powerC;

				lastError = error;

				if (integral > integraluplimit)

				{

					integral = integraltarget;

				}

				else

				{

					if (integral<integraldownlimit)

					{

						integral = integraltarget;

					}

					else

					{

					}

				}

			}

		}

	}

}
