#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp;

	float Ki;

	float Kd;

	float leftgreenlower;

	float leftgreenupper;

	float rightgreenlower;

	float rightgreenupper;

	float integraluplimit;

	float taruplimit;

	float motortarget;

	float reversemotortarget;

	float motorreset;

	float leftvalue;

	float rightvalue;

	float tardownlimit;

	float integraldownlimit;

	float integral;

	float integraltarget;

	float derivative;

	float derivativesetpoint;

	float lastError;

	float error;

	float turn;

	float powerB;

	float powerC;

	float tar = leftvalue - rightvalue;

	float sensordiff;

	float sensoraverage;

	float l;

	float r;

	float yes;

	float no;

	long x;

	float xvalue;

	float yvalue;

	float zvalue;

	long y;

	long z;

	long a;

	float avalue;

	float bvalue;

	float cvalue;

	long b;

	long c;

	float straighttarget;

	float turnaroundtarget;

	float turntarget;

	float leftratio;

	float rightratio;

	float nosquare;

	float greenturn;

	float turnlimit;

	float doublestraight;

	float average;

	float encodersetpoint;

	while (true)

	{

		Kp = 5.75;

		Ki = 0.01;

		Kd = 0.1;

		leftgreenlower = 2.75;

		leftgreenupper = 4.25;

		rightgreenlower = 1.25;

		rightgreenupper = 2.75;

		integraluplimit = 50.0;

		taruplimit = 15;

		motortarget = 15.0;

		reversemotortarget = 0.0 - motortarget;

		motorreset = 0.0;

		leftvalue = 60.0;

		rightvalue = 63.0;

		tardownlimit = 0.0 - taruplimit;

		integraldownlimit = 0.0 - integraluplimit;

		integral = 0.0;

		integraltarget = 0.0;

		derivative = 0.0;

		derivativesetpoint = 0.0;

		lastError = 0.0;

		tar = leftvalue - rightvalue;

		sensordiff = 0.01;

		sensoraverage = 20;

		yes = 1.0;

		no = 0.0;

		straighttarget = 360/(1.2 * PI) * 0.79;

		turnaroundtarget = 180 * 7.5/1.2;

		turntarget = 90 * 7.5/1.2;

		nosquare = motorreset - 11.0;

		greenturn = motorreset - 5.0;

		turnlimit = 14.0;

		doublestraight = 2.0;

		average = 2.0;

		encodersetpoint = 0.0;

		while (l == no && r == no)

		{

			if (tardownlimit < xvalue - avalue && xvalue - avalue < taruplimit)

			{

				tar = xvalue - avalue;

			}

			else

			{

				tar = leftvalue - rightvalue;

			}

			error = xvalue - avalue - tar;

			integral = integral + error;

			if (error < derivativesetpoint)

			{

				derivative = derivativesetpoint - (fabs(error - lastError))/average;

			}

			else

			{

				derivative = (fabs(error - lastError))/average;

			}

			turn = (Kp * error) + (Ki * integral) + (Kd * derivative);

			powerB = motortarget + turn;

			powerC = motortarget - turn;

			motor[motorB] = powerB;

			motor[motorC] = powerC;

			lastError = error;

			if (integral > integraluplimit)

			{

				integral = integraltarget;

			}

			else

			{

				if (integral < integraldownlimit)

				{

					integral = integraltarget;

				}

				else

				{

				}

			}

			getColorRGB(S2, x, y, z);

			getColorRGB(S3, a, b, c);

			xvalue = (float)(x);

			yvalue = (float)(y);

			zvalue = (float)(z);

			avalue = (float)(a);

			bvalue = (float)(b);

			cvalue = (float)(c);

			leftratio = (yvalue + sensordiff)/(zvalue + sensordiff);

			rightratio = (bvalue + sensordiff)/(cvalue + sensordiff);

			if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > sensoraverage)

			{

				l = yes;

			}

			else

			{

				l = no;

			}

			if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > sensoraverage)

			{

				r = yes;

			}

			else

			{

				r = no;

			}

		}

		if (l == yes && r == yes)

		{

			motor[motorB] = motorreset;

			motor[motorC] = motorreset;

			nMotorEncoder[motorB] = motorreset;

			nMotorEncoder[motorC] = motorreset;

			while(nMotorEncoder[motorB] < straighttarget)

			{

				motor[motorB] = motortarget;

				motor[motorC] = motortarget;

			}

			motor[motorB] = motorreset;

			motor[motorC] = motorreset;

			nMotorEncoder[motorB] = motorreset;

			nMotorEncoder[motorC] = motorreset;

			getColorRGB(S2, x, y, z);

			getColorRGB(S3, a, b, c);

			xvalue = (float)(x);

			yvalue = (float)(y);

			zvalue = (float)(z);

			avalue = (float)(a);

			bvalue = (float)(b);

			cvalue = (float)(c);

			if (xvalue < sensoraverage && avalue < sensoraverage)

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < turnaroundtarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = reversemotortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < straighttarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = motortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				l = no;

				r = no;

			}

			else

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				if (xvalue > sensoraverage && avalue > sensoraverage)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

					{

						motor[motorB] = reversemotortarget;

						motor[motorC] = reversemotortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

				else

				{

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

			}

		}

		else

		{

			if (l == yes && r == no)

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < straighttarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = motortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				if (xvalue < sensoraverage)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorC] < turntarget)

					{

						motor[motorB] = greenturn;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

				else

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					if (xvalue > sensoraverage && avalue > sensoraverage)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

						{

							motor[motorB] = reversemotortarget;

							motor[motorC] = reversemotortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						while(avalue > turnlimit)

						{

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							motor[motorB] = nosquare;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						l = no;

						r = no;

					}

					else

					{

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						l = no;

						r = no;

					}

				}

			}

			else

			{

				if (l == no && r == yes)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					if (avalue < sensoraverage)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < turntarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = greenturn;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						l = no;

						r = no;

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (xvalue > sensoraverage && avalue > sensoraverage)

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

							{

								motor[motorB] = reversemotortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							while(xvalue > turnlimit)

							{

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								motor[motorB] = motortarget;

								motor[motorC] = nosquare;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < straighttarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

						else

						{

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

					}

				}

				else

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

			}

		}

		l = no;

		r = no;

	}

}
