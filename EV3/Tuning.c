#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp;

	float Ki;

	float Kd;

	float reversegreenturn;

	float largecheckturntarget;

	float turnamount;

	float leftgreenlower;

	float leftgreenupper;

	float rightgreenlower;

	float rightgreenupper;

	float integraluplimit;

	float taruplimit;

	float motortarget;

	float reversemotortarget;

	float motorreset;

	float smallstraighttarget;

	float leftvalue;

	float rightvalue;

	float tardownlimit;

	float integraldownlimit;

	float integral;

	float integraltarget;

	float derivative;

	float derivativesetpoint;

	float lastError;

	float error;

	float turn;

	float powerB;

	float powerC;

	float tar = leftvalue - rightvalue;

	float sensordiff;

	float sensoraverage;

	float l;

	float r;

	float yes;

	float no;

	long x;

	float xvalue;

	float yvalue;

	float zvalue;

	long y;

	long z;

	long a;

	float avalue;

	float bvalue;

	float cvalue;

	long b;

	long c;

	float straighttarget;

	float turnaroundtarget;

	float turntarget;

	float halfturntarget;

	float leftratio;

	float rightratio;

	float nosquare;

	float extraturntarget;

	float totalturntarget;

	float greenturn;

	float turnlimit;

	float doublestraight;

	float average;

	float encodersetpoint;

	float greenaverage;

	float smallturntarget;

	float lastxvalue;

	float lastavalue;

	float checkturntarget;

	float checkturn;

	float reversecheckturn;

	float wheelbase;

	float wheeldiameter;

	float doublegreenstraighttarget;

	while (true)

	{

		Kp = 5.75;

		Ki = 0.01;

		Kd = 0.1;

		wheelbase = 7.5;

		wheeldiameter = 1.2;

		leftgreenlower = 3.25;

		leftgreenupper = 5.25;

		rightgreenlower = 2.75;

		rightgreenupper = 4.25;

		checkturn = 20;

		largecheckturntarget = 70 * wheelbase/wheeldiameter;

		reversecheckturn = 0.0 - checkturn;

		checkturntarget = 130 * wheelbase/wheeldiameter;

		integraluplimit = 50.0;

		taruplimit = 17.5;

		motortarget = 30.0;

		reversemotortarget = 0.0 - motortarget;

		motorreset = 0.0;

		leftvalue = 60.0;

		rightvalue = 63.0;

		tardownlimit = 0.0 - taruplimit;

		integraldownlimit = 0.0 - integraluplimit;

		integral = 0.0;

		integraltarget = 0.0;

		derivative = 0.0;

		derivativesetpoint = 0.0;

		lastError = 0.0;

		tar = leftvalue - rightvalue;

		sensordiff = 0.01;

		sensoraverage = 20;

		greenaverage = 15;

		turnamount = 1.5;

		yes = 1.0;

		no = 0.0;

		straighttarget = 360/(wheeldiameter * PI) * 0.6;

		doublegreenstraighttarget = 360/(wheeldiameter * PI) * 0.15;

		smallstraighttarget = 360/(wheeldiameter * PI) * 0.3;

		turnaroundtarget = 180 * wheelbase/wheeldiameter;

		turntarget = 90 * wheelbase/wheeldiameter;

		nosquare = motorreset - 22.0;

		greenturn = motorreset - 10.0;

		reversegreenturn = 0.0 - greenturn;

		turnlimit = 14.0;

		doublestraight = 2.0;

		average = 2.0;

		encodersetpoint = 0.0;

		smallturntarget = 10 * wheelbase/wheeldiameter;

		halfturntarget = 30 * wheelbase/wheeldiameter;

		extraturntarget = 25 * wheelbase/wheeldiameter;

		totalturntarget = 55 * wheelbase/wheeldiameter;

		while (l == no && r == no)

		{

			getColorRGB(S2, x, y, z);

			getColorRGB(S3, a, b, c);

			xvalue = (float)(x);

			yvalue = (float)(y);

			zvalue = (float)(z);

			avalue = (float)(a);

			bvalue = (float)(b);

			cvalue = (float)(c);

			if (tardownlimit < xvalue - avalue && xvalue - avalue < taruplimit)

			{

				tar = xvalue - avalue;

			}

			else

			{

				tar = leftvalue - rightvalue;

			}

			error = xvalue - avalue - tar;

			integral = integral + error;

			if (error < derivativesetpoint)

			{

				derivative = derivativesetpoint - (fabs(error - lastError))/average;

			}

			else

			{

				derivative = (fabs(error - lastError))/average;

			}

			turn = (Kp * error) + (Ki * integral) + (Kd * derivative);

			powerB = motortarget + turn;

			powerC = motortarget - turn;

			if (xvalue < sensoraverage && avalue < sensoraverage)

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < average * straighttarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = motortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorC] < smallturntarget)

				{

					motor[motorB] = greenturn;

					motor[motorC] = motortarget;

				}

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				if (avalue < sensoraverage)

				{

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

					{

						l = yes;

					}

					else

					{

						l = no;

					}

					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

					{

						r = yes;

					}

					else

					{

						r = no;

					}

					lastxvalue = xvalue;

					lastavalue = avalue;

				}

				else

				{

					if (xvalue < sensoraverage)

					{

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

						rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

						if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

						{

							l = yes;

						}

						else

						{

							l = no;

						}

						if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

						{

							r = yes;

						}

						else

						{

							r = no;

						}

						lastxvalue = xvalue;

						lastavalue = avalue;

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorC] > (0.0 - smallturntarget))

						{

							motor[motorB] = reversegreenturn;

							motor[motorC] = reversemotortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < smallturntarget)

						{

							motor[motorC] = greenturn;

							motor[motorB] = motortarget;

						}

						if (avalue < sensoraverage)

						{

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

							{

								l = yes;

							}

							else

							{

								l = no;

							}

							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

							{

								r = yes;

							}

							else

							{

								r = no;

							}

							lastxvalue = xvalue;

							lastavalue = avalue;

						}

						else

						{

							if (xvalue < sensoraverage)

							{

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

								rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

								if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

								{

									l = yes;

								}

								else

								{

									l = no;

								}

								if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

								{

									r = yes;

								}

								else

								{

									r = no;

								}

								lastxvalue = xvalue;

								lastavalue = avalue;

							}

							else

							{

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								while(nMotorEncoder[motorB] > (0.0 - smallturntarget))

								{

									motor[motorC] = reversegreenturn;

									motor[motorB] = reversemotortarget;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								while (xvalue > sensoraverage && avalue > sensoraverage)

								{

									motor[motorB] = reversemotortarget;

									motor[motorC] = reversemotortarget;

									getColorRGB(S2, x, y, z);

									getColorRGB(S3, a, b, c);

									xvalue = (float)(x);

									yvalue = (float)(y);

									zvalue = (float)(z);

									avalue = (float)(a);

									bvalue = (float)(b);

									cvalue = (float)(c);

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								while (nMotorEncoder[motorB] < smallstraighttarget)

								{

									motor[motorB] = motortarget;

									motor[motorC] = motortarget;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								if (xvalue <= sensoraverage)

								{

									while(nMotorEncoder[motorC] < checkturntarget && avalue > sensoraverage)

									{

										motor[motorC] = motortarget;

										motor[motorB] = reversecheckturn;

										getColorRGB(S2, x, y, z);

										getColorRGB(S3, a, b, c);

										xvalue = (float)(x);

										yvalue = (float)(y);

										zvalue = (float)(z);

										avalue = (float)(a);

										bvalue = (float)(b);

										cvalue = (float)(c);

									}

									motor[motorB] = motorreset;

									motor[motorC] = motorreset;

									nMotorEncoder[motorB] = motorreset;

									nMotorEncoder[motorC] = motorreset;

									if (avalue <= sensoraverage)

									{

										getColorRGB(S2, x, y, z);

										getColorRGB(S3, a, b, c);

										xvalue = (float)(x);

										yvalue = (float)(y);

										zvalue = (float)(z);

										avalue = (float)(a);

										bvalue = (float)(b);

										cvalue = (float)(c);

										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

										{

											l = yes;

										}

										else

										{

											l = no;

										}

										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

										{

											r = yes;

										}

										else

										{

											r = no;

										}

										lastxvalue = xvalue;

										lastavalue = avalue;

									}

									else

									{

										motor[motorB] = motorreset;

										motor[motorC] = motorreset;

										nMotorEncoder[motorB] = motorreset;

										nMotorEncoder[motorC] = motorreset;

										while(nMotorEncoder[motorB] < largecheckturntarget)

										{

											motor[motorB] = checkturn;

											motor[motorC] = reversemotortarget;

										}

										motor[motorB] = motorreset;

										motor[motorC] = motorreset;

										nMotorEncoder[motorB] = motorreset;

										nMotorEncoder[motorC] = motorreset;

										while(nMotorEncoder[motorB] < checkturntarget && xvalue > sensoraverage)

										{

											motor[motorB] = motortarget;

											motor[motorC] = reversecheckturn;

											getColorRGB(S2, x, y, z);

											getColorRGB(S3, a, b, c);

											xvalue = (float)(x);

											yvalue = (float)(y);

											zvalue = (float)(z);

											avalue = (float)(a);

											bvalue = (float)(b);

											cvalue = (float)(c);

										}

									}

								}

								else

								{

									while(nMotorEncoder[motorB] < checkturntarget && xvalue > sensoraverage)

									{

										motor[motorB] = motortarget;

										motor[motorC] = reversecheckturn;

										getColorRGB(S2, x, y, z);

										getColorRGB(S3, a, b, c);

										xvalue = (float)(x);

										yvalue = (float)(y);

										zvalue = (float)(z);

										avalue = (float)(a);

										bvalue = (float)(b);

										cvalue = (float)(c);

									}

									motor[motorB] = motorreset;

									motor[motorC] = motorreset;

									nMotorEncoder[motorB] = motorreset;

									nMotorEncoder[motorC] = motorreset;

									if (xvalue <= sensoraverage)

									{

										getColorRGB(S2, x, y, z);

										getColorRGB(S3, a, b, c);

										xvalue = (float)(x);

										yvalue = (float)(y);

										zvalue = (float)(z);

										avalue = (float)(a);

										bvalue = (float)(b);

										cvalue = (float)(c);

										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

										{

											l = yes;

										}

										else

										{

											l = no;

										}

										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

										{

											r = yes;

										}

										else

										{

											r = no;

										}

										lastxvalue = xvalue;

										lastavalue = avalue;

									}

									else

									{

										motor[motorB] = motorreset;

										motor[motorC] = motorreset;

										nMotorEncoder[motorB] = motorreset;

										nMotorEncoder[motorC] = motorreset;

										while(nMotorEncoder[motorC] < largecheckturntarget)

										{

											motor[motorC] = checkturn;

											motor[motorB] = reversemotortarget;

										}

										motor[motorB] = motorreset;

										motor[motorC] = motorreset;

										nMotorEncoder[motorB] = motorreset;

										nMotorEncoder[motorC] = motorreset;

										while(nMotorEncoder[motorC] < checkturntarget && avalue > sensoraverage)

										{

											motor[motorC] = motortarget;

											motor[motorB] = reversecheckturn;

											getColorRGB(S2, x, y, z);

											getColorRGB(S3, a, b, c);

											xvalue = (float)(x);

											yvalue = (float)(y);

											zvalue = (float)(z);

											avalue = (float)(a);

											bvalue = (float)(b);

											cvalue = (float)(c);

										}

									}

								}

							}

						}

					}

				}

			}

			else

			{

				if (xvalue < sensoraverage && avalue < sensoraverage)

				{

					if (lastxvalue < sensoraverage)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorC] < halfturntarget)

						{

							motor[motorB] = greenturn;

							motor[motorC] = motortarget;

						}

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (avalue < sensoraverage)

						{

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorC] < extraturntarget)

							{

								motor[motorB] = greenturn;

								motor[motorC] = motortarget;

							}

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (avalue<sensoraverage)

						{

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorC] > motorreset - halfturntarget)

							{

								motor[motorB] = reversegreenturn;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > turnamount * (motorreset - straighttarget))

							{

								motor[motorB] = reversemotortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < totalturntarget)

							{

								motor[motorC] = greenturn;

								motor[motorB] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

						}

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < halfturntarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = greenturn;

						}

						if (xvalue < sensoraverage)

						{

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < extraturntarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = greenturn;

							}

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (xvalue<sensoraverage)

						{

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > motorreset - halfturntarget)

							{

								motor[motorC] = reversegreenturn;

								motor[motorB] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > turnamount * (motorreset - straighttarget))

							{

								motor[motorB] = reversemotortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorC] < totalturntarget)

							{

								motor[motorB] = greenturn;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

						}

					}

				}

				else

				{

					motor[motorB] = powerB;

					motor[motorC] = powerC;

					lastError = error;

					if (integral > integraluplimit)

					{

						integral = integraltarget;

					}

					else

					{

						if (integral < integraldownlimit)

						{

							integral = integraltarget;

						}

						else

						{

						}

					}

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

					{

						l = yes;

					}

					else

					{

						l = no;

					}

					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

					{

						r = yes;

					}

					else

					{

						r = no;

					}

					lastxvalue = xvalue;

					lastavalue = avalue;

				}

			}

		}

		if (l == yes && r == yes)

		{

			motor[motorB] = motorreset;

			motor[motorC] = motorreset;

			nMotorEncoder[motorB] = motorreset;

			nMotorEncoder[motorC] = motorreset;

			while(nMotorEncoder[motorB] < straighttarget)

			{

				motor[motorB] = motortarget;

				motor[motorC] = motortarget;

			}

			motor[motorB] = motorreset;

			motor[motorC] = motorreset;

			nMotorEncoder[motorB] = motorreset;

			nMotorEncoder[motorC] = motorreset;

			getColorRGB(S2, x, y, z);

			getColorRGB(S3, a, b, c);

			xvalue = (float)(x);

			yvalue = (float)(y);

			zvalue = (float)(z);

			avalue = (float)(a);

			bvalue = (float)(b);

			cvalue = (float)(c);

			if (xvalue < sensoraverage && avalue < sensoraverage)

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < turnaroundtarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = reversemotortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < straighttarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = motortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				l = no;

				r = no;

			}

			else

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				if (xvalue > sensoraverage && avalue > sensoraverage)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

					{

						motor[motorB] = reversemotortarget;

						motor[motorC] = reversemotortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

				else

				{

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

			}

		}

		else

		{

			if (l == yes && r == no)

			{

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				while(nMotorEncoder[motorB] < doublegreenstraighttarget)

				{

					motor[motorB] = motortarget;

					motor[motorC] = motortarget;

				}

				motor[motorB] = motorreset;

				motor[motorC] = motorreset;

				nMotorEncoder[motorB] = motorreset;

				nMotorEncoder[motorC] = motorreset;

				delay(1000);

				getColorRGB(S2, x, y, z);

				getColorRGB(S3, a, b, c);

				xvalue = (float)(x);

				yvalue = (float)(y);

				zvalue = (float)(z);

				avalue = (float)(a);

				bvalue = (float)(b);

				cvalue = (float)(c);

				leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

				rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

				if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

				{

					l = yes;

				}

				else

				{

					l = no;

				}

				if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

				{

					r = yes;

				}

				else

				{

					r = no;

				}

				lastxvalue = xvalue;

				lastavalue = avalue;

				if (r == yes)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					if (xvalue < sensoraverage && avalue < sensoraverage)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < turnaroundtarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = reversemotortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						l = no;

						r = no;

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (xvalue > sensoraverage && avalue > sensoraverage)

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

							{

								motor[motorB] = reversemotortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

						else

						{

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

					}

				}

				else

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					if (xvalue < sensoraverage)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorC] < turntarget)

						{

							motor[motorB] = greenturn;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						l = no;

						r = no;

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (xvalue > sensoraverage && avalue > sensoraverage)

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

							{

								motor[motorB] = reversemotortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							while(avalue > turnlimit)

							{

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								motor[motorB] = nosquare;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < straighttarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

						else

						{

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

					}

				}

			}

			else

			{

				if (l == no && r == yes)

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < doublegreenstraighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					delay(1000);

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);

					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);

					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)

					{

						l = yes;

					}

					else

					{

						l = no;

					}

					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)

					{

						r = yes;

					}

					else

					{

						r = no;

					}

					lastxvalue = xvalue;

					lastavalue = avalue;

					if (l == yes)

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (xvalue < sensoraverage && avalue < sensoraverage)

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < turnaroundtarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = reversemotortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < straighttarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							if (xvalue > sensoraverage && avalue > sensoraverage)

							{

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

								{

									motor[motorB] = reversemotortarget;

									motor[motorC] = reversemotortarget;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								l = no;

								r = no;

							}

							else

							{

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								l = no;

								r = no;

							}

						}

					}

					else

					{

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						while(nMotorEncoder[motorB] < straighttarget)

						{

							motor[motorB] = motortarget;

							motor[motorC] = motortarget;

						}

						motor[motorB] = motorreset;

						motor[motorC] = motorreset;

						nMotorEncoder[motorB] = motorreset;

						nMotorEncoder[motorC] = motorreset;

						getColorRGB(S2, x, y, z);

						getColorRGB(S3, a, b, c);

						xvalue = (float)(x);

						yvalue = (float)(y);

						zvalue = (float)(z);

						avalue = (float)(a);

						bvalue = (float)(b);

						cvalue = (float)(c);

						if (avalue < sensoraverage)

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < turntarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = greenturn;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							while(nMotorEncoder[motorB] < straighttarget)

							{

								motor[motorB] = motortarget;

								motor[motorC] = motortarget;

							}

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							l = no;

							r = no;

						}

						else

						{

							motor[motorB] = motorreset;

							motor[motorC] = motorreset;

							nMotorEncoder[motorB] = motorreset;

							nMotorEncoder[motorC] = motorreset;

							getColorRGB(S2, x, y, z);

							getColorRGB(S3, a, b, c);

							xvalue = (float)(x);

							yvalue = (float)(y);

							zvalue = (float)(z);

							avalue = (float)(a);

							bvalue = (float)(b);

							cvalue = (float)(c);

							if (xvalue > sensoraverage && avalue > sensoraverage)

							{

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))

								{

									motor[motorB] = reversemotortarget;

									motor[motorC] = reversemotortarget;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								while(xvalue > turnlimit)

								{

									getColorRGB(S2, x, y, z);

									getColorRGB(S3, a, b, c);

									xvalue = (float)(x);

									yvalue = (float)(y);

									zvalue = (float)(z);

									avalue = (float)(a);

									bvalue = (float)(b);

									cvalue = (float)(c);

									motor[motorB] = motortarget;

									motor[motorC] = nosquare;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								while(nMotorEncoder[motorB] < straighttarget)

								{

									motor[motorB] = motortarget;

									motor[motorC] = motortarget;

								}

								motor[motorB] = motorreset;

								motor[motorC] = motorreset;

								nMotorEncoder[motorB] = motorreset;

								nMotorEncoder[motorC] = motorreset;

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								l = no;

								r = no;

							}

							else

							{

								getColorRGB(S2, x, y, z);

								getColorRGB(S3, a, b, c);

								xvalue = (float)(x);

								yvalue = (float)(y);

								zvalue = (float)(z);

								avalue = (float)(a);

								bvalue = (float)(b);

								cvalue = (float)(c);

								l = no;

								r = no;

							}

						}

					}

				}

				else

				{

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					while(nMotorEncoder[motorB] < straighttarget)

					{

						motor[motorB] = motortarget;

						motor[motorC] = motortarget;

					}

					motor[motorB] = motorreset;

					motor[motorC] = motorreset;

					nMotorEncoder[motorB] = motorreset;

					nMotorEncoder[motorC] = motorreset;

					getColorRGB(S2, x, y, z);

					getColorRGB(S3, a, b, c);

					xvalue = (float)(x);

					yvalue = (float)(y);

					zvalue = (float)(z);

					avalue = (float)(a);

					bvalue = (float)(b);

					cvalue = (float)(c);

					l = no;

					r = no;

				}

			}

		}

		l = no;

		r = no;

	}

}
