#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp;

	float Ki;

	float Kd;

	float leftgreenlower;

	float leftgreenupper;

	float rightgreenlower;

	float rightgreenupper;

	float integraluplimit;

	float taruplimit;

	float motortarget;

	float reversemotortarget;

	float motorreset;

	float leftvalue;

	float rightvalue;

	float tardownlimit;

	float integraldownlimit;

	float integral;

	float integraltarget;

	float derivative;

	float derivativesetpoint;

	float lastError;

	float error;

	float turn;

	float powerB;

	float powerC;

	float tar = leftvalue - rightvalue;

	float sensordiff;

	float sensoraverage;

	float yes;

	float no;

	long x;

	float xvalue;

	float yvalue;

	float zvalue;

	long y;

	long z;

	long a;

	float avalue;

	float bvalue;

	float cvalue;

	long b;

	long c;

	float straighttarget;

	float turnaroundtarget;

	float turntarget;

	float nosquare;

	float greenturn;

	float turnlimit;

	float doublestraight;

	float average;

	float encodersetpoint;

	while (true)

	{

		Kp = 5.75;

		Ki = 0.01;

		Kd = 0.1;

		leftgreenlower = 2.75;

		leftgreenupper = 4.25;

		rightgreenlower = 1.25;

		rightgreenupper = 2.75;

		integraluplimit = 50.0;

		taruplimit = 16;

		motortarget = 30.0;

		reversemotortarget = 0.0 - motortarget;

		motorreset = 0.0;

		leftvalue = 60.0;

		rightvalue = 63.0;

		tardownlimit = 0.0 - taruplimit;

		integraldownlimit = 0.0 - integraluplimit;

		integral = 0.0;

		integraltarget = 0.0;

		derivative = 0.0;

		derivativesetpoint = 0.0;

		lastError = 0.0;

		tar = leftvalue - rightvalue;

		sensordiff = 0.01;

		sensoraverage = 20;

		yes = 1.0;

		no = 0.0;

		straighttarget = 360/(1.2 * PI) * 0.79;

		turnaroundtarget = 180 * 7.5/1.2;

		turntarget = 90 * 7.5/1.2;

		nosquare = motorreset - 22.0;

		greenturn = motorreset - 10.0;

		turnlimit = 14.0;

		doublestraight = 2.0;

		average = 2.0;

		encodersetpoint = 0.0;

		getColorRGB(S2, x, y, z);

		getColorRGB(S3, a, b, c);

		xvalue = (float)(x);

		yvalue = (float)(y);

		zvalue = (float)(z);

		avalue = (float)(a);

		bvalue = (float)(b);

		cvalue = (float)(c);

		if (tardownlimit < xvalue - avalue && xvalue - avalue < taruplimit)

		{

			tar = xvalue - avalue;

		}

		else

		{

			tar = leftvalue - rightvalue;

		}

		error = xvalue - avalue - tar;

		integral = integral + error;

		if (error < derivativesetpoint)

		{

			derivative = derivativesetpoint - (fabs(error - lastError))/average;

		}

		else

		{

			derivative = (fabs(error - lastError))/average;

		}

		turn = (Kp * error) + (Ki * integral) + (Kd * derivative);

		powerB = motortarget + turn;

		powerC = motortarget - turn;

		motor[motorB] = powerB;

		motor[motorC] = powerC;

		lastError = error;

		if (integral > integraluplimit)

		{

			integral = integraltarget;

		}

		else

		{

			if (integral < integraldownlimit)

			{

				integral = integraltarget;

			}

			else

			{

			}

		}

	}

}
