#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_IRSensor)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void sensorvalues()
{
	long x;
	float xvalue;
	float yvalue;
	float zvalue;
	long y;
	long z;
	long a;
	float avalue;
	float bvalue;
	float cvalue;
	long b;
	long c;
	getColorRGB(S2, x, y, z);
	getColorRGB(S3, a, b, c);
	xvalue = (float)(x);
	yvalue = (float)(y);
	zvalue = (float)(z);
	avalue = (float)(a);
	bvalue = (float)(b);
	cvalue = (float)(c);
}

task main()
{
	// All variables initiated
	float Kp;
	float Ki;
	float Kd;
	float reversegreenturn;
	float largecheckturntarget;
	float turnamount;
	float leftgreenlower;
	float leftgreenupper;
	float rightgreenlower;
	float rightgreenupper;
	float integraluplimit;
	float taruplimit;
	float motortarget;
	float reversemotortarget;
	int obsr;
	int threshold;
	int g;
	int h;
	float wb;
	float buffer;
	float inner;
	float outer;
	float wb2;
	float wd;
	float motorreset;
	float smallstraighttarget;
	float leftvalue;
	float greenstraighttarget;
	float rightvalue;
	float tardownlimit;
	float integraldownlimit;
	float integral;
	float integraltarget;
	float derivative;
	float derivativesetpoint;
	float verysmallstraighttarget;
	float lastError;
	float error;
	float obstacleturn;
	float turn;
	float powerB;
	float powerC;
	float tar = leftvalue - rightvalue;
	float sensordiff;
	float sensoraverage;
	float largedelayamount;
	float l;
	float r;
	float yes;
	float no;
	float obstaclemotor;
	float reverseobstaclemotor;
	long x;
	float xvalue;
	float yvalue;
	float zvalue;
	long y;
	float shortdistance;
	long z;
	long a;
	float avalue;
	float bvalue;
	float cvalue;
	long b;
	long c;
	float straighttarget;
	float turnaroundtarget;
	float smallobstacleturn;
	float delayamount;
	float turntarget;
	float halfturntarget;
	float leftratio;
	float rightratio;
	float nosquare;
	float extraturntarget;
	float totalturntarget;
	float greenturn;
	float turnlimit;
	float doublestraight;
	float value1;
	float value2;
	float forwardsensor;
	float average;
	float encodersetpoint;
	float greenaverage;
	float smallturntarget;
	float lastxvalue;
	float lastavalue;
	float checkturntarget;
	float checkturn;
	float reversecheckturn;
	float wheelbase;
	float wheeldiameter;
	float smallsensoraverage;
	float doublegreenstraighttarget;
	float leftrightratio;
	while (true)
	{
		// Most variables defined
		obstacleturn = 60;
		smallobstacleturn = 20;
		Kp = 5.75;
		delayamount = 500;
		largedelayamount = 1500;
		shortdistance = 3;
		Ki = 0.01;
		Kd = 0.1;
		wheelbase = 7.5;
		wheeldiameter = 1.2;
		leftgreenlower = 2;
		leftgreenupper = 6;
		rightgreenlower = 1.5;
		rightgreenupper = 5.5;
		checkturn = 20;
		largecheckturntarget = 90 * wheelbase/wheeldiameter;
		reversecheckturn = 0.0 - checkturn;
		checkturntarget = 130 * wheelbase/wheeldiameter;
		integraluplimit = 50.0;
		taruplimit = 25;
		motortarget = 30.0;
		reversemotortarget = 0.0 - motortarget;
		motorreset = 0.0;
		leftvalue = 60.0;
		rightvalue = 63.0;
		tardownlimit = 0.0 - taruplimit;
		integraldownlimit = 0.0 - integraluplimit;
		integral = 0.0;
		integraltarget = 0.0;
		derivative = 0.0;
		derivativesetpoint = 0.0;
		lastError = 0.0;
		tar = leftvalue - rightvalue;
		sensordiff = 0.01;
		sensoraverage = 20;
		smallsensoraverage = 10;
		obstaclemotor = 50;
		reverseobstaclemotor = 0 - 50;
		greenaverage = 15;
		turnamount = 1.5;
		yes = 1.0;
		no = 0.0;
		straighttarget = 360/(wheeldiameter * PI) * 0.78;
		doublegreenstraighttarget = 360/(wheeldiameter * PI) * 0.2;
		smallstraighttarget = 360/(wheeldiameter * PI) * 0.39;
		verysmallstraighttarget = 360/(wheeldiameter * PI) * 0.3;
		greenstraighttarget = 360/(wheeldiameter * PI) * 1;
		turnaroundtarget = 160 * wheelbase/wheeldiameter;
		turntarget = 80 * wheelbase/wheeldiameter;
		nosquare = motorreset - 22.0;
		greenturn = motorreset - 10.0;
		reversegreenturn = 0.0 - greenturn;
		turnlimit = 14.0;
		doublestraight = 2.0;
		average = 2.0;
		encodersetpoint = 0.0;
		leftrightratio = 1.7;
		smallturntarget = 10 * wheelbase/wheeldiameter;
		halfturntarget = 30 * wheelbase/wheeldiameter;
		extraturntarget = 25 * wheelbase/wheeldiameter;
		totalturntarget = 55 * wheelbase/wheeldiameter;
		value1 = 1;
		value2 = 2;
		forwardsensor = 5;
		// Line tracing
		while (l == no && r == no)
		{
			// Obstacle
			if (SensorValue[S4] <= forwardsensor)
			{
				// Remaining variables defined
				obsr = 8;
				threshold = 35;
				g = value1;
				h = 50;
				wb = 19.05;
				buffer = 5;
				inner = ((obsr + buffer)/(obsr + buffer + wb)) * h;
				outer = h;
				wb2 = 19.05;
				wd = 3.048;
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Turn left to check for wall
				while(nMotorEncoder[motorC] <= (wb2/wd) * obstacleturn)
				{
					motor[motorB] = reverseobstaclemotor;
					motor[motorC] = obstaclemotor;
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Check for wall: if wall, then turn right
				if(SensorValue[S4] <= threshold)
				{
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					while(nMotorEncoder[motorB] <= (wb2/wd) * leftrightratio * obstacleturn)
					{
						motor[motorB] = obstaclemotor;
						motor[motorC] = reverseobstaclemotor;
					}
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					g = value2;
				}
				// Initiating the turn process
				if (g == value1)
				{
					motor[motorB] = outer;
					motor[motorC] = inner;
				}
				if (g == value2)
				{
					motor[motorB] = inner;
					motor[motorC] = outer;
				}
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Completing the turn process
				while(SensorValue[S2] > threshold && SensorValue[S3] > threshold)
				{
					if (g == value1)
					{
						motor[motorB] = outer;
						motor[motorC] = inner;
					}
					if (g == value2)
					{
						motor[motorC] = outer;
						motor[motorB] = inner;
					}
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Turning to find the line
				if (g == value1)
				{
					while (nMotorEncoder[motorC] <= (wb2/wd) * smallobstacleturn)
					{
						motor[motorC] = obstaclemotor;
						motor[motorB] = motorreset;
					}
				}
				if (g == value2)
				{
					while (nMotorEncoder[motorB] <= (wb2/wd) * smallobstacleturn)
					{
						motor[motorB] = obstaclemotor;
						motor[motorC] = motorreset;
					}
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
			}
			// End of obstacle
			// Initiating line tracing
			getColorRGB(S2, x, y, z);
			getColorRGB(S3, a, b, c);
			xvalue = (float)(x);
			yvalue = (float)(y);
			zvalue = (float)(z);
			avalue = (float)(a);
			bvalue = (float)(b);
			cvalue = (float)(c);
			// Balancing sensor values
			if (tardownlimit < xvalue - avalue && xvalue - avalue < taruplimit)
			{
				tar = xvalue - avalue;
			}
			else
			{
				tar = leftvalue - rightvalue;
			}
			// Identifying sensor error, integral, and derivative
			error = xvalue - avalue - tar;
			integral = integral + error;
			if (error < derivativesetpoint)
			{
				derivative = derivativesetpoint - (fabs(error - lastError))/average;
			}
			else
			{
				derivative = (fabs(error - lastError))/average;
			}
			// Setting turn values
			turn = (Kp * error) + (Ki * integral) + (Kd * derivative);
			powerB = motortarget + turn;
			powerC = motortarget - turn;
			// Intersection (double-black)
			if (xvalue < sensoraverage && avalue < sensoraverage)
			{
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Moving forward to check for line
				while(nMotorEncoder[motorB] < average * straighttarget)
				{
					motor[motorB] = motortarget;
					motor[motorC] = motortarget;
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Line left check
				while(nMotorEncoder[motorC] < smallturntarget)
				{
					motor[motorB] = greenturn;
					motor[motorC] = motortarget;
				}
				getColorRGB(S2, x, y, z);
				getColorRGB(S3, a, b, c);
				xvalue = (float)(x);
				yvalue = (float)(y);
				zvalue = (float)(z);
				avalue = (float)(a);
				bvalue = (float)(b);
				cvalue = (float)(c);
				// Line found right sensor
				if (avalue < sensoraverage)
				{
					// Resetting sensors to check for green and return to line tracing
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
					{
						l = yes;
					}
					else
					{
						l = no;
					}
					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
					{
						r = yes;
					}
					else
					{
						r = no;
					}
					lastxvalue = xvalue;
					lastavalue = avalue;
				}
				else
				{
					// Line found left sensor
					if (xvalue < sensoraverage)
					{
						// Resetting sensors to check for green and return to line tracing
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
						rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
						if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
						{
							l = yes;
						}
						else
						{
							l = no;
						}
						if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
						{
							r = yes;
						}
						else
						{
							r = no;
						}
						lastxvalue = xvalue;
						lastavalue = avalue;
					}
					// No line found
					else
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Re-align robot
						while(nMotorEncoder[motorC] > (motorreset - smallturntarget))
						{
							motor[motorB] = reversegreenturn;
							motor[motorC] = reversemotortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Line right check
						while(nMotorEncoder[motorB] < smallturntarget)
						{
							motor[motorC] = greenturn;
							motor[motorB] = motortarget;
						}
						// Line found right sensor
						if (avalue < sensoraverage)
						{
							// Resetting sensors to check for green and return to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
							{
								l = yes;
							}
							else
							{
								l = no;
							}
							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
							{
								r = yes;
							}
							else
							{
								r = no;
							}
							lastxvalue = xvalue;
							lastavalue = avalue;
						}
						// No line found
						else
						{
							// Line found left sensor
							if (xvalue < sensoraverage)
							{
								// Resetting sensors to check for green and return to line tracing
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
								rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
								if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
								{
									l = yes;
								}
								else
								{
									l = no;
								}
								if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
								{
									r = yes;
								}
								else
								{
									r = no;
								}
								lastxvalue = xvalue;
								lastavalue = avalue;
							}
							// Still no line found
							else
							{
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// Re-align robot
								while(nMotorEncoder[motorB] > (motorreset - smallturntarget))
								{
									motor[motorC] = reversegreenturn;
									motor[motorB] = reversemotortarget;
								}
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								// Move backward until seeing black
								while (xvalue > sensoraverage && avalue > sensoraverage)
								{
									motor[motorB] = reversemotortarget;
									motor[motorC] = reversemotortarget;
									getColorRGB(S2, x, y, z);
									getColorRGB(S3, a, b, c);
									xvalue = (float)(x);
									yvalue = (float)(y);
									zvalue = (float)(z);
									avalue = (float)(a);
									bvalue = (float)(b);
									cvalue = (float)(c);
								}
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// Record values, then go forward again
								while (nMotorEncoder[motorB] < verysmallstraighttarget)
								{
									motor[motorB] = motortarget;
									motor[motorC] = motortarget;
								}
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// If left sensor hit black
								if (xvalue <= sensoraverage)
								{
									// Turn left for some amount unless hitting the line
									while(nMotorEncoder[motorC] < checkturntarget && avalue > sensoraverage && xvalue > smallsensoraverage)
									{
										motor[motorC] = motortarget;
										motor[motorB] = reversecheckturn;
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
									}
									motor[motorB] = motorreset;
									motor[motorC] = motorreset;
									nMotorEncoder[motorB] = motorreset;
									nMotorEncoder[motorC] = motorreset;
									// If line is there
									if (avalue <= sensoraverage || xvalue <= sensoraverage)
									{
										// Resetting sensors to check for green and return to line tracing
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
										{
											l = yes;
										}
										else
										{
											l = no;
										}
										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
										{
											r = yes;
										}
										else
										{
											r = no;
										}
										lastxvalue = xvalue;
										lastavalue = avalue;
									}
									// No line found
									else
									{
										// Turn right
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										while(nMotorEncoder[motorB] < largecheckturntarget)
										{
											motor[motorB] = checkturn;
											motor[motorC] = reversemotortarget;
										}
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										// Turn right until hitting the black line
										while(nMotorEncoder[motorB] < checkturntarget && xvalue > sensoraverage && avalue > smallsensoraverage)
										{
											motor[motorB] = motortarget;
											motor[motorC] = reversecheckturn;
											getColorRGB(S2, x, y, z);
											getColorRGB(S3, a, b, c);
											xvalue = (float)(x);
											yvalue = (float)(y);
											zvalue = (float)(z);
											avalue = (float)(a);
											bvalue = (float)(b);
											cvalue = (float)(c);
										}
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										// Resetting sensors to check for green and return to line tracing
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
										{
											l = yes;
										}
										else
										{
											l = no;
										}
										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
										{
											r = yes;
										}
										else
										{
											r = no;
										}
										lastxvalue = xvalue;
										lastavalue = avalue;
									}
								}
								// If right sensor hit black
								else
								{
									// Turn right for some amount unless hitting the line
									while(nMotorEncoder[motorB] < checkturntarget && xvalue > sensoraverage && avalue > smallsensoraverage)
									{
										motor[motorB] = motortarget;
										motor[motorC] = reversecheckturn;
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
									}
									motor[motorB] = motorreset;
									motor[motorC] = motorreset;
									nMotorEncoder[motorB] = motorreset;
									nMotorEncoder[motorC] = motorreset;
									// If line is there
									if (xvalue <= sensoraverage || avalue <= sensoraverage)
									{
										// Resetting sensors to check for green and return to line tracing
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
										{
											l = yes;
										}
										else
										{
											l = no;
										}
										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
										{
											r = yes;
										}
										else
										{
											r = no;
										}
										lastxvalue = xvalue;
										lastavalue = avalue;
									}
									// No line found
									else
									{
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										// Turn left
										while(nMotorEncoder[motorC] < largecheckturntarget)
										{
											motor[motorC] = checkturn;
											motor[motorB] = reversemotortarget;
										}
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										// Turn left until hitting the black line
										while(nMotorEncoder[motorC] < checkturntarget && avalue > smallsensoraverage && xvalue > sensoraverage)
										{
											motor[motorC] = motortarget;
											motor[motorB] = reversecheckturn;
											getColorRGB(S2, x, y, z);
											getColorRGB(S3, a, b, c);
											xvalue = (float)(x);
											yvalue = (float)(y);
											zvalue = (float)(z);
											avalue = (float)(a);
											bvalue = (float)(b);
											cvalue = (float)(c);
										}
										motor[motorB] = motorreset;
										motor[motorC] = motorreset;
										nMotorEncoder[motorB] = motorreset;
										nMotorEncoder[motorC] = motorreset;
										// Resetting sensors to check for green and return to line tracing
										getColorRGB(S2, x, y, z);
										getColorRGB(S3, a, b, c);
										xvalue = (float)(x);
										yvalue = (float)(y);
										zvalue = (float)(z);
										avalue = (float)(a);
										bvalue = (float)(b);
										cvalue = (float)(c);
										leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
										rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
										if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
										{
											l = yes;
										}
										else
										{
											l = no;
										}
										if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
										{
											r = yes;
										}
										else
										{
											r = no;
										}
										lastxvalue = xvalue;
										lastavalue = avalue;
									}
								}
							}
						}
					}
				}
			}
			// End of intersection (double-black)
			else
			{
				// Start of extreme intersection/diagonal (worst-case scenario)
				if (xvalue < sensoraverage && avalue < sensoraverage)
				{
					// If left-sensor remained black
					if (lastxvalue < sensoraverage)
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Move forward
						while(nMotorEncoder[motorB] < straighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Turn left
						while(nMotorEncoder[motorC] < halfturntarget)
						{
							motor[motorB] = greenturn;
							motor[motorC] = motortarget;
						}
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// If found line
						if (avalue < sensoraverage || xvalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Resetting sensors to check for green and return to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
							{
								l = yes;
							}
							else
							{
								l = no;
							}
							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
							{
								r = yes;
							}
							else
							{
								r = no;
							}
							lastxvalue = xvalue;
							lastavalue = avalue;
						}
						// No line found
						else
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn left more
							while(nMotorEncoder[motorC] < extraturntarget)
							{
								motor[motorB] = greenturn;
								motor[motorC] = motortarget;
							}
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						if (avalue < sensoraverage || xvalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Resetting sensors to check for green and return to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
							{
								l = yes;
							}
							else
							{
								l = no;
							}
							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
							{
								r = yes;
							}
							else
							{
								r = no;
							}
							lastxvalue = xvalue;
							lastavalue = avalue;
						}
						// Still no line found
						else
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Re-align robot
							while(nMotorEncoder[motorC] > motorreset - halfturntarget)
							{
								motor[motorB] = reversegreenturn;
								motor[motorC] = reversemotortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Go backwards to point of intersection
							while(nMotorEncoder[motorB] > turnamount * (motorreset - straighttarget))
							{
								motor[motorB] = reversemotortarget;
								motor[motorC] = reversemotortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn at a right angle to continue
							while(nMotorEncoder[motorB] < totalturntarget)
							{
								motor[motorC] = greenturn;
								motor[motorB] = motortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
						}
					}
					// If right-sensor remained black
					else
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Go forward
						while(nMotorEncoder[motorB] < straighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Turn right
						while(nMotorEncoder[motorB] < halfturntarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = greenturn;
						}
						// If found line
						if (xvalue < sensoraverage || avalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Resetting sensors to check for green and return to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
							{
								l = yes;
							}
							else
							{
								l = no;
							}
							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
							{
								r = yes;
							}
							else
							{
								r = no;
							}
							lastxvalue = xvalue;
							lastavalue = avalue;
						}
						// No line found
						else
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn left more
							while(nMotorEncoder[motorB] < extraturntarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = greenturn;
							}
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// If found line
						if (xvalue<sensoraverage || avalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Resetting sensors to check for green and return to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
							rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
							if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
							{
								l = yes;
							}
							else
							{
								l = no;
							}
							if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
							{
								r = yes;
							}
							else
							{
								r = no;
							}
							lastxvalue = xvalue;
							lastavalue = avalue;
						}
						// No line found
						else
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Re-align robot
							while(nMotorEncoder[motorB] > motorreset - halfturntarget)
							{
								motor[motorC] = reversegreenturn;
								motor[motorB] = reversemotortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Move backward to point of intersection
							while(nMotorEncoder[motorB] > turnamount * (motorreset - straighttarget))
							{
								motor[motorB] = reversemotortarget;
								motor[motorC] = reversemotortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn left at right angle to continue
							while(nMotorEncoder[motorC] < totalturntarget)
							{
								motor[motorB] = greenturn;
								motor[motorC] = motortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
						}
					}
				}
				// End of extreme intersection/diagonal (worst-case scenario)
				else
				{
					// Return to line tracing, actual movement
					motor[motorB] = powerB;
					motor[motorC] = powerC;
					lastError = error;
					// Reset integral if too large
					if (integral > integraluplimit)
					{
						integral = integraltarget;
					}
					else
					{
						if (integral < integraldownlimit)
						{
							integral = integraltarget;
						}
						else
						{
						}
					}
					// Resetting sensors to check for green and restart line tracing
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
					{
						l = yes;
					}
					else
					{
						l = no;
					}
					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
					{
						r = yes;
					}
					else
					{
						r = no;
					}
					lastxvalue = xvalue;
					lastavalue = avalue;
				}
			}
		}
		// End of line tracing
		// Start of green square
		// Start of double green
		if (l == yes && r == yes)
		{
			motor[motorB] = motorreset;
			motor[motorC] = motorreset;
			nMotorEncoder[motorB] = motorreset;
			nMotorEncoder[motorC] = motorreset;
			// Move forward to check for black line
			while(nMotorEncoder[motorB] < straighttarget)
			{
				motor[motorB] = motortarget;
				motor[motorC] = motortarget;
			}
			motor[motorB] = motorreset;
			motor[motorC] = motorreset;
			nMotorEncoder[motorB] = motorreset;
			nMotorEncoder[motorC] = motorreset;
			getColorRGB(S2, x, y, z);
			getColorRGB(S3, a, b, c);
			xvalue = (float)(x);
			yvalue = (float)(y);
			zvalue = (float)(z);
			avalue = (float)(a);
			bvalue = (float)(b);
			cvalue = (float)(c);
			// Check for black line
			if (xvalue < sensoraverage && avalue < sensoraverage)
			{
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Turn all the way around
				while(nMotorEncoder[motorB] < turnaroundtarget)
				{
					motor[motorB] = motortarget;
					motor[motorC] = reversemotortarget;
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Re-adjust to line
				while(nMotorEncoder[motorB] < straighttarget)
				{
					motor[motorB] = motortarget;
					motor[motorC] = motortarget;
				}
				// Reset sensors to proceed to line tracing
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				getColorRGB(S2, x, y, z);
				getColorRGB(S3, a, b, c);
				xvalue = (float)(x);
				yvalue = (float)(y);
				zvalue = (float)(z);
				avalue = (float)(a);
				bvalue = (float)(b);
				cvalue = (float)(c);
				l = no;
				r = no;
			}
			else
			{
				// If no black line
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				getColorRGB(S2, x, y, z);
				getColorRGB(S3, a, b, c);
				xvalue = (float)(x);
				yvalue = (float)(y);
				zvalue = (float)(z);
				avalue = (float)(a);
				bvalue = (float)(b);
				cvalue = (float)(c);
				// If both white
				if (xvalue > sensoraverage && avalue > sensoraverage)
				{
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Move back to green
					while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))
					{
						motor[motorB] = reversemotortarget;
						motor[motorC] = reversemotortarget;
					}
					// Reset to restart line tracing
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					l = no;
					r = no;
				}
				else
				{
					// Reset to restart line tracing
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					l = no;
					r = no;
				}
			}
		}
		// End of double green
		else
		{
			// Start of left green
			if (l == yes && r == no)
			{
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Move slightly
				while(nMotorEncoder[motorC] < doublegreenstraighttarget)
				{
					motor[motorB] = 0;
					motor[motorC] = motortarget;
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Identify green
				getColorRGB(S2, x, y, z);
				getColorRGB(S3, a, b, c);
				xvalue = (float)(x);
				yvalue = (float)(y);
				zvalue = (float)(z);
				avalue = (float)(a);
				bvalue = (float)(b);
				cvalue = (float)(c);
				leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
				rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
				if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
				{
					l = yes;
				}
				else
				{
					l = no;
				}
				if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
				{
					r = yes;
				}
				else
				{
					r = no;
				}
				lastxvalue = xvalue;
				lastavalue = avalue;
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// Re-align robot
				while(nMotorEncoder[motorB] < doublegreenstraighttarget)
				{
					motor[motorB] = motortarget;
					motor[motorC] = 0;
				}
				motor[motorB] = motorreset;
				motor[motorC] = motorreset;
				nMotorEncoder[motorB] = motorreset;
				nMotorEncoder[motorC] = motorreset;
				// If right is green
				if (r == yes)
				{
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Move forward
					while(nMotorEncoder[motorB] < greenstraighttarget)
					{
						motor[motorB] = motortarget;
						motor[motorC] = motortarget;
					}
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Check for black
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					// If black line
					if (xvalue < sensoraverage && avalue < sensoraverage)
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Turn around to the opposite direction
						while(nMotorEncoder[motorB] < turnaroundtarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = reversemotortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Adjust onto line
						while(nMotorEncoder[motorB] < straighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						// Proceed to line tracing
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						l = no;
						r = no;
					}
					// If not black
					else
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// Check for white
						if (xvalue > sensoraverage && avalue > sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Move back to green
							while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))
							{
								motor[motorB] = reversemotortarget;
								motor[motorC] = reversemotortarget;
							}
							// Reset to restart line tracing
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
						else
						{
							// Reset to restart line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
					}
				}
				// If right is not green
				else
				{
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Check for black
					while(nMotorEncoder[motorB] < straighttarget)
					{
						motor[motorB] = motortarget;
						motor[motorC] = motortarget;
					}
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					// If black
					if (xvalue < sensoraverage)
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Turn left
						while(nMotorEncoder[motorC] < turntarget)
						{
							motor[motorB] = greenturn;
							motor[motorC] = motortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Align with line
						while(nMotorEncoder[motorB] < straighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						// Reset to restart line tracing
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						l = no;
						r = no;
					}
					else
					{
						// Reset to take values
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// If white
						if (xvalue > sensoraverage && avalue > sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Move backward to green
							while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))
							{
								motor[motorB] = reversemotortarget;
								motor[motorC] = reversemotortarget;
							}
							// Reset to take value
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							// Turn to get back on line
							while(avalue > turnlimit)
							{
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								motor[motorB] = nosquare;
								motor[motorC] = motortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Re-align with line
							while(nMotorEncoder[motorB] < straighttarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = motortarget;
							}
							// Reset to restart line tracing
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
						else
						{
							// Reset to restart line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
					}
				}
			}
			// End of left green
			else
			{
				// Start of right green
				if (l == no && r == yes)
				{
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Turn slightly to check for green
					while(nMotorEncoder[motorB] < doublegreenstraighttarget)
					{
						motor[motorB] = motortarget;
						motor[motorC] = 0;
					}
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Check green with sensors
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					leftratio = (yvalue + sensordiff)/(xvalue + sensordiff);
					rightratio = (bvalue + sensordiff)/(avalue + sensordiff);
					if (leftratio > leftgreenlower && leftratio < leftgreenupper && yvalue > greenaverage)
					{
						l = yes;
					}
					else
					{
						l = no;
					}
					if (rightratio > rightgreenlower && rightratio < rightgreenupper && bvalue > greenaverage)
					{
						r = yes;
					}
					else
					{
						r = no;
					}
					lastxvalue = xvalue;
					lastavalue = avalue;
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Re-align robot
					while(nMotorEncoder[motorC] < doublegreenstraighttarget)
					{
						motor[motorB] = 0;
						motor[motorC] = motortarget;
					}
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// If left is green
					if (l == yes)
					{
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Go forward to check for black
						while(nMotorEncoder[motorB] < greenstraighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// If black
						if (xvalue < sensoraverage && avalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn around
							while(nMotorEncoder[motorB] < turnaroundtarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = reversemotortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Go forward to re-align with the line
							while(nMotorEncoder[motorB] < straighttarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = motortarget;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Reset to proceed to line tracing
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
						else
						{
							// If no black
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							// Check for white
							if (xvalue > sensoraverage && avalue > sensoraverage)
							{
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// Move backward to green
								while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))
								{
									motor[motorB] = reversemotortarget;
									motor[motorC] = reversemotortarget;
								}
								// Reset values to restart line tracing
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								l = no;
								r = no;
							}
							else
							{
								// Reset values to restart line tracing
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								l = no;
								r = no;
							}
						}
					}
					else
					{
						// If left not green
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						// Forward to check for black
						while(nMotorEncoder[motorB] < straighttarget)
						{
							motor[motorB] = motortarget;
							motor[motorC] = motortarget;
						}
						motor[motorB] = motorreset;
						motor[motorC] = motorreset;
						nMotorEncoder[motorB] = motorreset;
						nMotorEncoder[motorC] = motorreset;
						getColorRGB(S2, x, y, z);
						getColorRGB(S3, a, b, c);
						xvalue = (float)(x);
						yvalue = (float)(y);
						zvalue = (float)(z);
						avalue = (float)(a);
						bvalue = (float)(b);
						cvalue = (float)(c);
						// If black
						if (avalue < sensoraverage)
						{
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Turn right
							while(nMotorEncoder[motorB] < turntarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = greenturn;
							}
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							// Go forward to re-align with line
							while(nMotorEncoder[motorB] < straighttarget)
							{
								motor[motorB] = motortarget;
								motor[motorC] = motortarget;
							}
							// Reset to restart line tracing
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							l = no;
							r = no;
						}
						else
						{
							// Reset to take values
							motor[motorB] = motorreset;
							motor[motorC] = motorreset;
							nMotorEncoder[motorB] = motorreset;
							nMotorEncoder[motorC] = motorreset;
							getColorRGB(S2, x, y, z);
							getColorRGB(S3, a, b, c);
							xvalue = (float)(x);
							yvalue = (float)(y);
							zvalue = (float)(z);
							avalue = (float)(a);
							bvalue = (float)(b);
							cvalue = (float)(c);
							// If white
							if (xvalue > sensoraverage && avalue > sensoraverage)
							{
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// Go backward to green
								while(nMotorEncoder[motorB] > (encodersetpoint - (doublestraight * straighttarget)))
								{
									motor[motorB] = reversemotortarget;
									motor[motorC] = reversemotortarget;
								}
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								// Turn to find line
								while(xvalue > turnlimit)
								{
									getColorRGB(S2, x, y, z);
									getColorRGB(S3, a, b, c);
									xvalue = (float)(x);
									yvalue = (float)(y);
									zvalue = (float)(z);
									avalue = (float)(a);
									bvalue = (float)(b);
									cvalue = (float)(c);
									motor[motorB] = motortarget;
									motor[motorC] = nosquare;
								}
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								// Forward to re-align with line
								while(nMotorEncoder[motorB] < straighttarget)
								{
									motor[motorB] = motortarget;
									motor[motorC] = motortarget;
								}
								// Reset to restart line tracing
								motor[motorB] = motorreset;
								motor[motorC] = motorreset;
								nMotorEncoder[motorB] = motorreset;
								nMotorEncoder[motorC] = motorreset;
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								l = no;
								r = no;
							}
							else
							{
								// Reset to restart line tracing
								getColorRGB(S2, x, y, z);
								getColorRGB(S3, a, b, c);
								xvalue = (float)(x);
								yvalue = (float)(y);
								zvalue = (float)(z);
								avalue = (float)(a);
								bvalue = (float)(b);
								cvalue = (float)(c);
								l = no;
								r = no;
							}
						}
					}
				}
				else
				{
					// If no green
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					// Go forward to re-align with line
					while(nMotorEncoder[motorB] < straighttarget)
					{
						motor[motorB] = motortarget;
						motor[motorC] = motortarget;
					}
					// Reset to restart line tracing
					motor[motorB] = motorreset;
					motor[motorC] = motorreset;
					nMotorEncoder[motorB] = motorreset;
					nMotorEncoder[motorC] = motorreset;
					getColorRGB(S2, x, y, z);
					getColorRGB(S3, a, b, c);
					xvalue = (float)(x);
					yvalue = (float)(y);
					zvalue = (float)(z);
					avalue = (float)(a);
					bvalue = (float)(b);
					cvalue = (float)(c);
					l = no;
					r = no;
				}
			}
		}
		// Set to line tracing
		l = no;
		r = no;
	}
}
