#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          mediumMotor,   tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp = 5;

	float taruplimit = 8;

	float motortarget = 30.0;

	float leftvalue = 60.0;

	float rightvalue = 63.0;

	float tardownlimit = 0.0 - taruplimit;

	float turn;

	float error;

	float powerB;

	float powerC;

	long x;

	float xvalue;

	long y;

	long z;

	long a;

	float avalue;

	long b;

	long c;

	float tar = leftvalue-rightvalue;

	while (true)

	{

		getColorRGB(S2, x, y, z);

		getColorRGB(S3, a, b, c);

		xvalue = (float)(x);

		avalue = (float)(a);

		if (tardownlimit<xvalue-avalue & xvalue-avalue<taruplimit)

		{

			tar = xvalue - avalue;

		}

		else

		{

			tar = leftvalue-rightvalue;

		}

		error = xvalue - avalue - tar;

		turn = (Kp*error);

		if (turn<10 & turn>-10)

		{

			powerB = 30;

			powerC = 30;

		}

		else

		{

			if (turn>10)

			{

				powerB = motortarget+turn;

				powerC = 0;

			}

			else

			{

				powerB = 0;

				powerC = motortarget+turn;

			}

		}

		motor[motorB] = powerB;

		motor[motorC] = powerC;

	}

}
