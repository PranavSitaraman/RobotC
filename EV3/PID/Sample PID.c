#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          mediumMotor,   tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()

{

	float Kp = 3.2;

	float Ki = 0.1;

	float Kd = 1;

	float q = 0.5;

	float r = 0.9;

	float s = 1;

	float taruplimit = 8;

	float time = 1;

	float motortarget = 30.0;

	float integraluplimit = 100.0;

	float leftvalue = 60.0;

	float rightvalue = 63.0;

	float tardownlimit = 0.0 - taruplimit;

	float integraldownlimit = 0.0 - integraluplimit;

	float lastDerivative = 0.0;

	float integral = 0.0;

	float integraltarget = 0.0;

	float derivative = 0.0;

	float derivativetarget = 1.0;

	float lastError = 0.0;

	float error;

	float error1;

	float error2;

	float lastError2;

	float turn;

	float powerB;

	float powerC;

	long x;

	float xvalue;

	long y;

	long z;

	long a;

	float avalue;

	long b;

	long c;

	float tar = leftvalue-rightvalue;

	while (true)

	{

		getColorRGB(S2, x, y, z);

		getColorRGB(S3, a, b, c);

		xvalue = (float)(x);

		avalue = (float)(a);

		if (tardownlimit<xvalue-avalue & xvalue-avalue<taruplimit)

		{

			tar = xvalue - avalue;

		}

		else

		{

			tar = leftvalue-rightvalue;

		}

		error = xvalue - avalue - tar;

		error1 = s*xvalue - avalue - tar;

		error2 = r*xvalue - avalue - tar;

		integral = integral+error;

		derivative = q * (error2 - lastError2)/time + (derivativetarget - q) * (lastDerivative);

		turn = ((Kp*error1)+(Ki*integral*time)+(Kd*derivative));

		powerB = motortarget+turn;

		powerC = motortarget-turn;

		motor[motorB] = powerB;

		motor[motorC] = powerC;

		lastError = error;

		lastError2 = error2;

		lastDerivative = derivative;

		if (integral > integraluplimit)

		{

			integral = integraltarget;

		}

		else

		{

			if (integral<integraldownlimit)

			{

				integral = integraltarget;

			}

			else

			{

			}

		}

	}

}
